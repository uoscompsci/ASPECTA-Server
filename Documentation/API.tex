\documentclass{acm_proc_article-sp}

% UTF8 encoding and scalable fonts
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{microtype}

\usepackage{graphicx}

\usepackage{url}

\usepackage{listings}
\usepackage{color}
\usepackage{enumitem}

% Comment in when writing in German
%\usepackage{ngerman}

\setcounter{secnumdepth}{5}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{
	commentstyle=\color{mygreen},
	keywordstyle=\color{blue},
	stringstyle=\color{mymauve},
	showstringspaces=false
}

\begin{document}

% Leave as is
\CopyrightYear{2014} 

% Change to your title
\title{API Documentation}

% Change to your personal details
\numberofauthors{1} 
\author{
Julian Petford\\
       \affaddr{Computer Science Department}\\
       \affaddr{University of St Andrews}\\
       \affaddr{St Andrews, UK}\\
       \email{jp438@st-andrews.ac.uk}
}

\maketitle

\section{API Calls}
\subsection{Initializing a connection}
After running server.py then creating an instance of messageSender, you need to log into the server so that it can give objects you create appropriate identifiers. You do this by making both of the following calls.
\subsubsection{login(username)}
Logs the user in with the given username.
\subsubsection{setapp(appname)}
Sets the application name for the current application.

\subsection{Surface Management}
Surfaces act as the lowest level of the GUI tree that represents what is being shown on the walls. The outer curves of a surface dictate the transformations that occur to make the image appear unwarped on the wall. Surface creation is generally handled by the configuration program, however the following API calls exist for surface management.
\subsubsection{newSurface()}
This call creates a surface object and returns its surface number (surfaceNo) to be used as an identifier by future calls.
\subsubsection{newSurfaceWithID(ID)}
This call creates a new surface with an identifier of the user's choice and returns its surface number (surfaceNo) to be used as an identifier by future calls.
\subsubsection{getSurfaceID(surfaceNo)}
This call returns the ID of the surface with the given surface number.
\subsubsection{setSurfaceID(surfaceNo, ID)}
This call sets the ID of the surface with the given surface number.
\subsubsection{getSurfaceOwner(surfaceNo)}
This call returns the owner name of the surface with the given surface number.
\subsubsection{getSurfaceAppDetails(surfaceNo)}
This call returns the application details of the surface with the given surface number. This is returned as a tuple containing the application name and the instance number.
\subsubsection{getSurfacesByID(ID)}
This call returns a list of surface numbers containing all surfaces that have the queried ID.
\subsubsection{getSurfacesByOwner(owner)}
This call returns a list of surface numbers containing all surfaces that have the queried owner.
\subsubsection{getSurfacesByAppName(name)}
This call returns a list of surface numbers containing all surfaces that have the queried application name.
\subsubsection{getSurfacesByAppDetails(name, instance)}
This call returns a list of surface numbers containing all surfaces that have the queried application name and instance number.
\subsubsection{setSurfaceEdges(surfaceNo, topPoints, bottomPoints, leftPoints, rightPoints)}
Sets the edge points of the surface with the given surface number. topPoints, bottomPoints, leftPoints and rightPoints should all be lists of (x,y) coordinate tuples.
\subsubsection{undefineSurface(surfaceNo)}
Undefines the edge points allocated to a surface. It will no longer be rendered until the points are redefined.
\subsubsection{saveDefinedSurfaces(filename)}
Saves the defined surface layout in the room at the server name with the requested file name.
\subsubsection{loadDefinedSurfaces(filename)}
Loads a layout from the server-side file with the given name and returns a (count, surfaceslist, connections) tuple.
\subsubsection{getSavedLayouts()}
Returns a list of all the layouts stored on the server side.
\subsubsection{deleteLayout(name)}
Deletes the surface layout with the given name from the server.
\subsubsection{setSurfacePixelHeight(surfaceNo, height)}
Sets the height in pixels of the texture which is going to be applied to the given surface.
\subsubsection{setSurfacePixelWidth(surfaceNo, width)}
Sets the width in pixels of the texture which is going to be applied to the given surface.
\subsubsection{getSurfacePixelHeight(surfaceNo)}
Gets the height in pixels of the texture which is going to be applied to the given surface.
\subsubsection{getSurfacePixelWidth(surfaceNo)}
Gets the width in pixels of the texture which is going to be applied to the given surface.
\subsubsection{setSurfaceRealHeight(surfaceNo, height)}
Sets the height in centimetres of the texture which is going to be applied to the given surface.
\subsubsection{setSurfaceRealWidth(surfaceNo, width)}
Sets the width in centimetres of the texture which is going to be applied to the given surface.
\subsubsection{getSurfaceRealHeight(surfaceNo)}
Gets the height in centimetres of the texture which is going to be applied to the given surface.
\subsubsection{getSurfaceRealWidth(surfaceNo)}
Gets the width in centimetres of the texture which is going to be applied to the given surface.
\subsubsection{clearSurface(surfaceNo)}
Removes all windows and elements from the given surface.
\subsubsection{rotateSurfaceTo0(surfaceNo)}
Makes it so that the top left of the surface matches up with the top left of the surface's texture.
\subsubsection{rotateSurfaceTo90(surfaceNo)}
Makes it so that the top right of the surface matches up with the top left of the surface's texture.
\subsubsection{rotateSurfaceTo180(surfaceNo)}
Makes it so that the bottom right of the surface matches up with the top left of the surface's texture.
\subsubsection{rotateSurfaceTo270(surfaceNo)}
Makes it so that the bottom left of the surface matches up with the top left of the surface's texture.
\subsubsection{mirrorSurface(surfaceNo)}
mirrors the texture of the surface around the top left / bottom right diagonal.
\subsubsection{connectSufaces(surfaceNo1, side1, surfaceNo2, side2)}
Creates a connection between a side of one surface and a side of another surface so that cursors can move between the surfaces. Sides should be given as one of the strings "top", "bottom", "left" or "right".
\subsubsection{disconnectSurfaces(surfaceNo1, side1, surfaceNo2, side2)}
Removes the connection between two surface sides. Sides should be given as one of the strings "top", "bottom", "left" or "right".

\subsection{Window Management}
Windows are placed on surfaces, so that users can attach elements to them. Windows can be moved and all the elements they contain will be moved too.
\subsubsection{newWindow(surfaceNo, x, y, width, height, coorSys, name)}
This call creates a new window object and returns its window number (windowNo) to be used as an identifier by future calls. The user must supply the number of the surface the window is being applied to, the x and y coordinates on the surface it should be positioned at, and its width and height. The coordinate system that the user wants to use should also be stated as either "pix" for pixels, "prop" for the proportion of the height/width of the surface (between 0 and 1) or "real" for centimetres.
\subsubsection{newWindowWithID(ID, surfaceNo, x, y, width, height, coorSys, name)}
This call creates a new window object with an identifier of the user's choice and returns its window number (windowNo) to be used as an identifier by future calls. The user must supply the number of the surface the window is being applied to, the x and y coordinates on the surface it should be positioned at, and its width and height. The coordinate system that the user wants to use should also be stated as either "pix" for pixels, "prop" for the proportion of the height/width of the surface (between 0 and 1) or "real" for centimetres.
\subsubsection{getWindowID(windowNo)}
This call returns the ID of the window with the given window number.
\subsubsection{setWindowID(windowNo, ID)}
This call sets the ID of the window with the given window number.
\subsubsection{getWindowOwner(windowNo)}
This call returns the owner name of the window with the given window number.
\subsubsection{getWindowAppDetails(windowNo)}
This call returns the application details of the window with the given window number. This is returned as a tuple containing the application name and the instance number.
\subsubsection{getWindowsByID(ID)}
This call returns a list of window numbers containing all windows that have the queried ID.
\subsubsection{getWindowsByOwner(owner)}
This call returns a list of window numbers containing all windows that have the queried owner.
\subsubsection{getWindowsByAppName(name)}
This call returns a list of window numbers containing all windows that have the queried application name.
\subsubsection{getWindowsByAppDetails(name, instance)}
This call returns a list of window numbers containing all windows that have the queried application name and instance number.
\subsubsection{moveWindow(windowNo, xDistance, yDistance, coorSys)}
This call moves the stated window by the given x and y distances.
\subsubsection{relocateWindow(windowNo, x, y, coorSys, surfaceNo)}
This call relocates the stated window to the given position on the given surface.
\subsubsection{getWindowPosition(windowNo)}
This call returns the position of the stated window as an (x,y) tuple.
\subsubsection{setWindowWidth(windowNo, width, coorSys)}
This call resets the width of the stated window to the chosen value.
\subsubsection{setWindowHeight(windowNo, height, coorSys)}
This call resets the height of the stated window to the chosen value.
\subsubsection{getWindowWidth(windowNo, width)}
This call returns the width of the stated window.
\subsubsection{getWindowHeight(windowNo, height)}
This call returns the height of the stated window.
\subsubsection{stretchWindowDown(windowNo, distance, coorSys)}
This call stretches the stated window down by the chosen number of pixels.
\subsubsection{stretchWindowUp(windowNo, distance, coorSys)}
This call stretches the stated window up by the chosen number of pixels.
\subsubsection{stretchWindowLeft(windowNo, distance, coorSys)}
This call stretches the stated window left by the chosen number of pixels.
\subsubsection{stretchWindowRight(windowNo, distance, coorSys)}
This call stretches the stated window right by the chosen number of pixels.
\subsubsection{setWindowName(windowNo, name)}
This call sets the name of the stated window to the chosen value.
\subsubsection{getWindowName(windowNo)}
This call returns the name of the stated window.
\subsection{Cursor Management}
Cursor calls can be locked to mouse events to control a cursor on the wall. For instance, a program could track how much a mouse has moved regularly, and send a message using shiftCursor() to duplicate this action on screen. When the user clicks a button on the mouse getCursorPosition() can be used to find the position of the mouse at the moment of the click and act accordingly.
\subsubsection{newCursor(surfaceNo, x, y, coorSys)}
This call creates a new cursor object and returns its cursor number (cursorNo) to be used as an identifier by future calls. The user must supply the number of the surface the circle is being added to and the x and y coordinates of the cursor on the surface. The coordinate system that the user wants to use should also be stated as either "pix" for pixels, "prop" for the proportion of the height/width of the surface (between 0 and 1) or "real" for centimetres.
\subsubsection{newCursorWithID(ID, surfaceNo, x, y, coorSys)}
This call creates a new cursor object with an identifier of the user's choice and returns its cursor number (cursorNo) to be used as an identifier by future calls. The user must supply the number of the surface the circle is being added to and the x and y coordinates of the cursor on the surface. The coordinate system that the user wants to use should also be stated as either "pix" for pixels, "prop" for the proportion of the height/width of the surface (between 0 and 1) or "real" for centimetres.
\subsubsection{shiftCursor(cursorNo, xDistance, yDistance)}
This call moves the cursor with the given cursor number the requested x and y distances from its current location. Corrections are automatically made for cursor rotation.
\subsubsection{testShiftCursor(cursorNo, xDistance, yDistance)}
This call tests moving the cursor with the given cursor number the requested x and y distances from its current location. The hypothetical new coordinates are returned as an (x,y) tuple.
\subsubsection{relocateCursor(cursorNo, x, y, surfaceNo)}
This call relocates the cursor with the given cursor number to the requested x and y coordinates on the surface with the given surface number.
\subsubsection{getCursorPosition(cursorNo)}
This call returns the coordinates of the cursor with the given cursor number as an (x,y) tuple.
\subsubsection{rotateCursorClockwise(cursorNo, degrees)}
This call rotates the cursor with the given cursor number clockwise by the requested number of degrees.
\subsubsection{rotateCursorAnticlockwise(cursorNo, degrees)}
This call rotates the cursor with the given cursor number anticlockwise by the requested number of degrees.
\subsubsection{getCursorRotation(cursorNo)}
This call returns the current clockwise rotation of the cursor with the given cursor number.
\subsubsection{getCursorMode(cursorNo)}
This call returns the mode of the cursor with the given cursor number as a string.
\subsubsection{setCursorDefaultMode(cursorNo)}
This call sets the mode of the cursor with the given cursor number to "default".
\subsubsection{setCursorWallMode(cursorNo)}
This call sets the mode of the cursor with the given cursor number to "wall".
\subsubsection{setCursorBlockMode(cursorNo)}
This call sets the mode of the cursor with the given cursor number to "block".
\subsubsection{setCursorScreenMode(cursorNo)}
This call sets the mode of the cursor with the given cursor number to "screen".
\subsubsection{showCursor(cursorNo)}
This call makes the cursor with the given cursor number visible.
\subsubsection{hideCursor(cursorNo)}
This call makes the cursor with the given cursor number invisible.
\subsubsection{isCursorVisible(cursorNo)}
This call returns a boolean stating whether the cursor with the given cursor number is visible.
\subsection{General Element Management}
Elements are objects that can be placed on windows. There are many different types of element including rectangles, lines and text. Here are the calls that can be used for all types of element.
\subsubsection{getElementID(elementNo)}
This call returns the ID of the element with the given element number.
\subsubsection{setElementID(elementNo, ID)}
This call sets the ID of the element with the given element number.
\subsubsection{getElementOwner(elementNo)}
This call returns the owner name of the element with the given element number.
\subsubsection{getElementAppDetails(elementNo)}
This call returns the application details of the element with the given element number. This is returned as a tuple containing the application name and the instance number.
\subsubsection{getElementsByID(ID)}
This call returns a list of element numbers containing all elements that have the queried ID.
\subsubsection{getElementsByOwner(owner)}
This call returns a list of element numbers containing all elements that have the queried owner.
\subsubsection{getElementsByAppName(name)}
This call returns a list of element numbers containing all elements that have the queried application name.
\subsubsection{getElementsByAppDetails(name, instance)}
This call returns a list of element numbers containing all elements that have the queried application name and instance number.
\subsubsection{getElementsOnWindow(windowNo)}
This call returns a list of element numbers containing all elements that are contained within the given window.
\subsubsection{getElementType(elementNo)}
This call returns a string stating the type of element the given element is. (e.g. "circle")
\subsubsection{showElement(elementNo)}
This call makes the given element visible.
\subsubsection{hideElement(elementNo)}
This call makes the given element invisible.
\subsubsection{checkElementVisibility(elementNo)}
This call return a boolean value stating if the given element is visible.
\subsubsection{removeElement(elementNo, windowNo)}
This call deletes the given element from the given window.
\subsection{Circle Management (Element Subclass)}
\subsubsection{newCircle(windowNo, x, y, radius, coorSys, lineCol, lineWidth, fillCol, sides)}
This call creates a new circle object and returns its element number (elementNo) to be used as an identifier by future calls. The user must supply the number of the window the circle is being added to, the x and y coordinates of the center point on the window, and its radius, line color (currently ignored), fill color and the number of sides the circle has (this defines the quality of the circle). Colors should be passed in as an (r,g,b,$\alpha$) tuple where the values of r, g, b and $\alpha$ are between 0 and 1. The coordinate system that the user wants to use should also be stated as either "pix" for pixels, "prop" for the proportion of the height/width of the surface (between 0 and 1) or "real" for centimetres.
\subsubsection{newCircleWithID(ID, windowNo, x, y, radius, coorSys, lineCol, lineWidth, fillCol, sides)}
This call creates a new circle object with an identifier of the user's choice and returns its element number (elementNo) to be used as an identifier by future calls. The user must supply the number of the window the circle is being added to, the x and y coordinates of the center point on the window, and its radius, line color (currently ignored), fill color and the number of sides the circle has (this defines the quality of the circle). Colors should be passed in as an (r,g,b,$\alpha$) tuple where the values of r, g, b and $\alpha$ are between 0 and 1. The coordinate system that the user wants to use should also be stated as either "pix" for pixels, "prop" for the proportion of the height/width of the surface (between 0 and 1) or "real" for centimetres.
\subsubsection{relocateCircle(elementNo, x, y, coorSys, windowNo)}
This call relocates the circle with the given element number to the given position on the given window.
\subsubsection{shiftCircle(elementNo, xDist, yDist, coorSys)}
This call shifts the circle with the given element number by the given distances on the x and y axes.
\subsubsection{getCirclePosition(elementNo)}
This call returns an (x,y) tuple containing the coordinates of the circle with the given element number.
\subsubsection{setCircleLineColor(elementNo, color)}
This call sets the line color of the circle with the given element number. Colors should be passed in as an (r,g,b,$\alpha$) tuple where the values of r, g, b and $\alpha$ are between 0 and 1.
\subsubsection{setCircleLineWidth(elementNo, width)}
This call sets the line width of the circle with the given element number.
\subsubsection{setCircleFillColor(elementNo, color)}
This call sets the fill color of the circle with the given element number. Colors should be passed in as an (r,g,b,$\alpha$) tuple where the values of r, g, b and $\alpha$ are between 0 and 1.
\subsubsection{getCircleLineColor(elementNo)}
This call gets the line color of the circle with the given element number. Colors are returned as an (r,g,b,$\alpha$) tuple where the values of r, g, b and $\alpha$ are between 0 and 1.
\subsubsection{getCircleLineWidth(elementNo, width)}
This call gets the line width of the circle with the given element number.
\subsubsection{getCircleFillColor(elementNo)}
This call gets the fill color of the circle with the given element number. Colors are returned as an (r,g,b,$\alpha$) tuple where the values of r, g, b and $\alpha$ are between 0 and 1.
\subsubsection{setCircleRadius(elementNo, radius, coorSys)}
This call sets the radius of the circle with the given element number.
\subsubsection{getCircleRadius(elementNo)}
This call returns the radius of the circle with the given element number.
\subsubsection{setCircleSides(elementNo, sides)}
This call sets the number of sides that are used to define the circle with the given element number.
\subsubsection{getCircleSides(elementNo)}
This call returns the number of sides that are used to define the circle with the given element number.
\subsection{Line Management (Element Subclass)}
\subsubsection{newLine(windowNo, xStart, yStart, xEnd, yEnd, coorSys, color, width)}
This call creates a new line object and returns its element number (elementNo) to be used as an identifier by future calls. The user must supply the number of the window the line is being added to, the x and y coordinates of both the start and end points on the window, its width and color. Colors should be passed in as an (r,g,b,$\alpha$) tuple where the values of r, g, b and $\alpha$ are between 0 and 1. The coordinate system that the user wants to use should also be stated as either "pix" for pixels, "prop" for the proportion of the height/width of the surface (between 0 and 1) or "real" for centimetres.
\subsubsection{newLineWithID(ID, windowNo, xStart, yStart, xEnd, yEnd, coorSys, color, width)}
This call creates a new line object with an identifier of the user's choice and returns its element number (elementNo) to be used as an identifier by future calls. The user must supply the number of the window the line is being added to, the x and y coordinates of both the start and end points on the window, its width and color. Colors should be passed in as an (r,g,b,$\alpha$) tuple where the values of r, g, b and $\alpha$ are between 0 and 1. The coordinate system that the user wants to use should also be stated as either "pix" for pixels, "prop" for the proportion of the height/width of the surface (between 0 and 1) or "real" for centimetres.
\subsubsection{relocateLine(elementNo, refPoint, x, y, coorSys, windowNo)}
This call relocates the line with the given element number to the given position on the given window using either the start (0) or the end (1) as a reference point.
\subsubsection{shiftLine(elementNo, xDist, yDist, coorSys)}
This call shifts the line with the given element number by the given distances on the x and y axes.
\subsubsection{getLineStart(elementNo)}
This call returns the start location of the line with the given element number as a (x,y) tuple.
\subsubsection{setLineStart(elementNo, x, y, coorSys)}
This call sets the start location of the line with the given element number.
\subsubsection{getLineEnd(elementNo)}
This call returns the end location of the line with the given element number as a (x,y) tuple.
\subsubsection{setLineEnd(elementNo, x, y, coorSys)}
This call sets the end location of the line with the given element number.
\subsubsection{setLineColor(elementNo, color)}
This call sets the color of the line with the given element number. Colors should be passed in as an (r,g,b,$\alpha$) tuple where the values of r, g, b and $\alpha$ are between 0 and 1.
\subsubsection{getLineColor(elementNo)}
This call gets the color of the line with the given element number. Colors are returned as an (r,g,b,$\alpha$) tuple where the values of r, g, b and $\alpha$ are between 0 and 1.
\subsubsection{setLineWidth(elementNo, width)}
This call sets the width of the line with the given element number.
\subsubsection{getLineWidth(elementNo)}
This call gets the width of the line with the given element number.
\subsection{Line Strip Management (Element Subclass)}
\subsubsection{newLineStrip(windowNo, x, y, coorSys, color, width)}
This call creates a new line strip object and returns its element number (elementNo) to be used as an identifier by future calls. The user must supply the number of the window the line strip is being added to, the x and y coordinates of the start point on the window, its width and color. Colors should be passed in as an (r,g,b,$\alpha$) tuple where the values of r, g, b and $\alpha$ are between 0 and 1. The coordinate system that the user wants to use should also be stated as either "pix" for pixels, "prop" for the proportion of the height/width of the surface (between 0 and 1) or "real" for centimetres.
\subsubsection{newLineStripWithID(ID, windowNo, x, y, coorSys, color, width)}
This call creates a new line strip object with an identifier of the user's choice and returns its element number (elementNo) to be used as an identifier by future calls. The user must supply the number of the window the line strip is being added to, the x and y coordinates of the start point on the window, its width and color. Colors should be passed in as an (r,g,b,$\alpha$) tuple where the values of r, g, b and $\alpha$ are between 0 and 1. The coordinate system that the user wants to use should also be stated as either "pix" for pixels, "prop" for the proportion of the height/width of the surface (between 0 and 1) or "real" for centimetres.
\subsubsection{addLineStripPoint(elementNo, x, y, coorSys)}
This call adds a new point with the given coordinates onto the end of the line strip with the given element number.
\subsubsection{addLineStripPointAt(elementNo, x, y, coorSys, index)}
This call adds a new point with the given coordinates at the chosen index of the line strip with the given element number.
\subsubsection{relocateLineStrip(elementNo, refPoint, x, y, coorSys, windowNo)}
This call relocates the line strip with the given element number to the given position on the given window using either the point number supplied by the user as a reference point.
\subsubsection{shiftLineStrip(elementNo, xDist, yDist, coorSys)}
This call shifts the line strip with the given element number by the given distances on the x and y axes.
\subsubsection{getLineStripPoint(elementNo, pointNo)}
This call returns the coordinates of the chosen point of the line strip with the given element number as an (x,y) tuple.
\subsubsection{moveLineStripPoint(elementNo, pointNo, x, y, coorSys)}
This call resets the coordinates of the chosen point of the line strip with the given element number.
\subsubsection{setLineStripColor(elementNo, color)}
This call sets the color of the line strip with the given element number. Colors should be passed in as an (r,g,b,$\alpha$) tuple where the values of r, g, b and $\alpha$ are between 0 and 1.
\subsubsection{getLineStripColor(elementNo)}
This call gets the color of the line strip with the given element number. Colors are returned as an (r,g,b,$\alpha$) tuple where the values of r, g, b and $\alpha$ are between 0 and 1.
\subsubsection{setLineStripWidth(elementNo, width)}
This call sets the width of the line strip with the given element number.
\subsubsection{getLineStripWidth(elementNo)}
This call gets the width of the line strip with the given element number.
\subsubsection{getLineStripPointCount(elementNo)}
This call returns the number of points in the line strip with the given element number.
\subsubsection{setLineStripContent(elementNo, content)}
This call sets all the points of the line strip with the given element number when passed in as a list of (x,y) tuples.
\subsection{Polygon Management (Element Subclass)}
\subsubsection{newPolygon(windowNo, x, y, coorSys, lineColor, lineWidth, fillColor)}
This call creates a new polygon object and returns its element number (elementNo) to be used as an identifier by future calls. The user must supply the number of the window the polygon is being added to, the x and y coordinates of the first point on the window, its line color (currently ignored) and fill color. Colors should be passed in as an (r,g,b,$\alpha$) tuple where the values of r, g, b and $\alpha$ are between 0 and 1. The coordinate system that the user wants to use should also be stated as either "pix" for pixels, "prop" for the proportion of the height/width of the surface (between 0 and 1) or "real" for centimetres.
\subsubsection{newPolygonWithID(ID, windowNo, x, y, coorSys, lineColor, lineWidth, fillColor)}
This call creates a new polygon object with an identifier of the user's choice and returns its element number (elementNo) to be used as an identifier by future calls. The user must supply the number of the window the polygon is being added to, the x and y coordinates of the first point on the window, its line color (currently ignored) and fill color. Colors should be passed in as an (r,g,b,$\alpha$) tuple where the values of r, g, b and $\alpha$ are between 0 and 1. The coordinate system that the user wants to use should also be stated as either "pix" for pixels, "prop" for the proportion of the height/width of the surface (between 0 and 1) or "real" for centimetres.
\subsubsection{addPolygonPoint(elementNo, x, y, coorSys)}
This call adds a new point with the given coordinates onto the end of the list for the polygon with the given element number.
\subsubsection{relocatePolygon(elementNo, refPoint, x, y, coorSys, windowNo)}
This call relocates the polygon with the given element number to the given position on the given window using either the point number supplied by the user as a reference point.
\subsubsection{shiftPolygon(elementNo, xDist, yDist, coorSys)}
This call shifts the polygon with the given element number by the given distances on the x and y axes.
\subsubsection{getPolygonPoint(elementNo, pointNo)}
This call returns the coordinates of the chosen point in the polygon with the given element number as an (x,y) tuple.
\subsubsection{movePolygonPoint(elementNo, pointNo, x, y, coorSys)}
This call resets the coordinates of the chosen point in the polygon with the given element number.
\subsubsection{getPolygonFillColor(elementNo)}
This call gets the fill color of the polygon with the given element number. Colors are returned as an (r,g,b,$\alpha$) tuple where the values of r, g, b and $\alpha$ are between 0 and 1.
\subsubsection{setPolygonFillColor(elementNo, color)}
This call sets the fill color of the polygon with the given element number. Colors should be passed in as an (r,g,b,$\alpha$) tuple where the values of r, g, b and $\alpha$ are between 0 and 1.
\subsubsection{setPolygonLineColor(elementNo, color)}
This call sets the line color of the polygon with the given element number. Colors should be passed in as an (r,g,b,$\alpha$) tuple where the values of r, g, b and $\alpha$ are between 0 and 1.
\subsubsection{getPolygonLineColor(elementNo)}
This call gets the line color of the polygon with the given element number. Colors are returned as an (r,g,b,$\alpha$) tuple where the values of r, g, b and $\alpha$ are between 0 and 1.
\subsubsection{setPolygonLineWidth(elementNo, width)}
This call sets the line width of the polygon with the given element number.
\subsubsection{getPolygonLineWidth(elementNo)}
This call gets the line width of the polygon with the given element number.
\subsubsection{getPolygonPointCount(elementNo)}
This call returns the number of points in the polygon with the given element number.
\subsection{Rectangle Management (Element Subclass)}
\subsubsection{newRectangle(windowNo, x, y, width, height, coorSys, lineColor, lineWidth, fillColor)}
This call creates a new rectangle object and returns its element number (elementNo) to be used as an identifier by future calls. The user must supply the number of the window the rectangle is being added to, the x and y coordinates of the top-left point on the window, its width, height, line color (currently ignored) and fill color. Colors should be passed in as an (r,g,b,$\alpha$) tuple where the values of r, g, b and $\alpha$ are between 0 and 1. The coordinate system that the user wants to use should also be stated as either "pix" for pixels, "prop" for the proportion of the height/width of the surface (between 0 and 1) or "real" for centimetres.
\subsubsection{newRectangle(ID, windowNo, x, y, width, height, coorSys, lineColor, lineWidth, fillColor)}
This call creates a new rectangle object with an identifier of the user's choice and returns its element number (elementNo) to be used as an identifier by future calls. The user must supply the number of the window the rectangle is being added to, the x and y coordinates of the top-left point on the window, its width, height, line color (currently ignored) and fill color. Colors should be passed in as an (r,g,b,$\alpha$) tuple where the values of r, g, b and $\alpha$ are between 0 and 1. The coordinate system that the user wants to use should also be stated as either "pix" for pixels, "prop" for the proportion of the height/width of the surface (between 0 and 1) or "real" for centimetres.
\subsubsection{relocateRectangle(elementNo, x, y, coorSys, windowNo)}
This call sets the coordinates of the top-left corner of the rectangle with the given element number.
\subsubsection{shiftRectangle(elementNo, xDist, yDist, coorSys)}
This call shifts the rectangle with the given element number by the given distances on the x and y axes.
\subsubsection{getRectangleTopLeft(elementNo)}
This call returns the coordinates of the top-left of the rectangle with the given element number as an (x,y) tuple.
\subsubsection{getRectangleTopRight(elementNo)}
This call returns the coordinates of the top-right of the rectangle with the given element number as an (x,y) tuple.
\subsubsection{getRectangleBottomRight(elementNo)}
This call returns the coordinates of the bottom-right of the rectangle with the given element number as an (x,y) tuple.
\subsubsection{getRectangleBottomLeft(elementNo)}
This call returns the coordinates of the bottom-left of the rectangle with the given element number as an (x,y) tuple.
\subsubsection{setRectangleWidth(elementNo, width, coorSys)}
This call sets the width of the rectangle with the given element number.
\subsubsection{getRectangleWidth(elementNo)}
This call gets the width of the rectangle with the given element number.
\subsubsection{setRectangleHeight(elementNo, height, coorSys)}
This call sets the height of the rectangle with the given element number.
\subsubsection{getRectangleHeight(elementNo)}
This call gets the height of the rectangle with the given element number.
\subsubsection{getRectangleFillColor(elementNo)}
This call gets the fill color of the rectangle with the given element number. Colors are returned as an (r,g,b,$\alpha$) tuple where the values of r, g, b and $\alpha$ are between 0 and 1.
\subsubsection{setRectangleFillColor(elementNo, color)}
This call sets the fill color of the rectangle with the given element number. Colors should be passed in as an (r,g,b,$\alpha$) tuple where the values of r, g, b and $\alpha$ are between 0 and 1.
\subsubsection{setRectangleLineColor(elementNo, color)}
This call sets the line color of the rectangle with the given element number. Colors should be passed in as an (r,g,b,$\alpha$) tuple where the values of r, g, b and $\alpha$ are between 0 and 1.
\subsubsection{getRectangleLineColor(elementNo)}
This call gets the line color of the rectangle with the given element number. Colors are returned as an (r,g,b,$\alpha$) tuple where the values of r, g, b and $\alpha$ are between 0 and 1.
\subsubsection{setRectangleLineWidth(elementNo, width)}
This call sets the line width of the rectangle with the given element number.
\subsubsection{getRectangleLineWidth(elementNo)}
This call gets the line width of the rectangle with the given element number.
\subsection{Textured Rectangle Management (Element Subclass)}
\subsubsection{newTexRectangle(windowNo, x, y, width, height, coorSys, texture)}
This call creates a new textured rectangle object and returns its element number (elementNo) to be used as an identifier by future calls. The user must supply the number of the window the rectangle is being added to, the x and y coordinates of the top-left point on the window, its width, height and texture file name. The coordinate system that the user wants to use should also be stated as either "pix" for pixels, "prop" for the proportion of the height/width of the surface (between 0 and 1) or "real" for centimetres.
\subsubsection{newTexRectangle(ID, windowNo, x, y, width, height, coorSys, texture)}
This call creates a new textured rectangle object with an identifier of the user's choice and returns its element number (elementNo) to be used as an identifier by future calls. The user must supply the number of the window the rectangle is being added to, the x and y coordinates of the top-left point on the window, its width, height and texture file name. The coordinate system that the user wants to use should also be stated as either "pix" for pixels, "prop" for the proportion of the height/width of the surface (between 0 and 1) or "real" for centimetres.
\subsubsection{relocateTexRectangle(elementNo, x, y, coorSys, windowNo)}
This call sets the coordinates of the top-left corner of the textured rectangle with the given element number.
\subsubsection{shiftTexRectangle(elementNo, xDist, yDist, coorSys)}
This call shifts the textured rectangle with the given element number by the given distances on the x and y axes.
\subsubsection{getTexRectangleTopLeft(elementNo)}
This call returns the coordinates of the top-left of the textured rectangle with the given element number as an (x,y) tuple.
\subsubsection{getTexRectangleTopRight(elementNo)}
This call returns the coordinates of the top-right of the textured rectangle with the given element number as an (x,y) tuple.
\subsubsection{getTexRectangleBottomRight(elementNo)}
This call returns the coordinates of the bottom-right of the textured rectangle with the given element number as an (x,y) tuple.
\subsubsection{getTexRectangleBottomLeft(elementNo)}
This call returns the coordinates of the bottom-left of the textured rectangle with the given element number as an (x,y) tuple.
\subsubsection{getTexRectangleTexture(elementNo)}
This call returns the name of the texture which is being used for the textured rectangle with the given element number.
\subsubsection{setTexRectangleTexture(elementNo, texture)}
This call sets the texture which is being used for the textured rectangle with the given element number by name.
\subsubsection{setTexRectangleWidth(elementNo, width, coorSys)}
This call sets the width of the textured rectangle with the given element number.
\subsubsection{getTexRectangleWidth(elementNo)}
This call gets the width of the textured rectangle with the given element number.
\subsubsection{setTexRectangleHeight(elementNo, height, coorSys)}
This call sets the height of the textured rectangle with the given element number.
\subsubsection{getTexRectangleHeight(elementNo)}
This call gets the height of the textured rectangle with the given element number.
\subsection{Text Management (Element Subclass)}
\subsubsection{newText(windowNo, text, x, y, coorSys, ptSize, font, color)}
This call creates a new text block object and returns its element number (elementNo) to be used as an identifier by future calls. The user must supply the number of the window the text is being added to, the string that is being displayed, the x and y coordinates of the text on the window, it's point size, font and color. Colors should be passed in as an (r,g,b,$\alpha$) tuple where the values of r, g, b and $\alpha$ are between 0 and 1. The coordinate system that the user wants to use should also be stated as either "pix" for pixels, "prop" for the proportion of the height/width of the surface (between 0 and 1) or "real" for centimetres.
\subsubsection{newTextWithID(windowNo, text, x, y, coorSys, ptSize, font, color)}
This call creates a new text block object with an identifier of the user's choice and returns its element number (elementNo) to be used as an identifier by future calls. The user must supply the number of the window the text is being added to, the string that is being displayed, the x and y coordinates of the text on the window, it's point size, font and color. Colors should be passed in as an (r,g,b,$\alpha$) tuple where the values of r, g, b and $\alpha$ are between 0 and 1. The coordinate system that the user wants to use should also be stated as either "pix" for pixels, "prop" for the proportion of the height/width of the surface (between 0 and 1) or "real" for centimetres.
\subsubsection{setText(elementNo, text)}
This call sets the string which is shown for the text with the given element number.
\subsubsection{getText(elementNo)}
This call returns the string which is shown for the text with the given element number.
\subsubsection{relocateText(elementNo, x, y, coorSys, windowNo)}
This call resets the position of the text with the given element number.
\subsubsection{shiftText(elementNo, xDist, yDist, coorSys)}
This call shifts the text with the given element number by the given distances on the x and y axes.
\subsubsection{getTextPosition(elementNo)}
This call returns the position of the text with the given element number as an (x,y) tuple.
\subsubsection{setPointSize(elementNo, pointSize)}
This call sets the point size of the text with the given element number.
\subsubsection{getPointSize(elementNo, pointSize)}
This call returns the point size of the text with the given element number.
\subsubsection{setFont(elementNo, font)}
This call sets the font being used for the text with the given element number. This currently has to be one of the fonts that the server supports. ("Free Serif", "Free Mono" or "Free Sans")
\subsubsection{getFont(elementNo)}
This call returns the font being used for the text with the given element number.
\subsubsection{setTextColor(elementNo, color)}
This call sets the color of the text with the given element number. Colors should be passed in as an (r,g,b,$\alpha$) tuple where the values of r, g, b and $\alpha$ are between 0 and 1.
\subsubsection{getTextColor(elementNo)}
This call returns the color of the text with the given element number. Colors are returned as an (r,g,b,$\alpha$) tuple where the values of r, g, b and $\alpha$ are between 0 and 1.
\subsection{General Calls}
\subsubsection{quit()}
This call stops the looping of the message sender in preparation to close the program and sends the server a message to close as well.
\subsubsection{quitClientOnly()}
This call stops the looping of the message sender in preparation to close the program.
\subsubsection{uploadImage(file)}
This call sends the image file that the user stated the location of to the server so that it can be used within future programs as a texture.
\subsubsection{getSavedImages()}
Returns a list of all the images stored on the server side.
\subsubsection{deleteImage(filename)}
Deletes the image with the given file name from the server.
\section{Hello World}
Here is a hello world program that can be run after the walls have been set up in the configuration program. It assumes the user has set up surface 1 and displays the text "Hello World" in the center.
\lstset{language=Python}
\begin{lstlisting}[frame=single]
from messageSender import *

#Create Connection
sender = messageSender()

#Log into the server
sender.login("username")
sender.setapp("helloworld")

#Check the width and height of the surface
height = sender.getSurfacePixelHeight(1)
width = sender.getSurfacePixelWidth(1)

#Create a window that covers the whole 
#surface
win = sender.newWindow(1, 0, height, width, 
	height, "pix", "HWwin")
	
#Render the words "Hello World" in the 
#middle of the window.
sender.newText(win, "Hello World", 
	height/2-150, width/2-25, "pix", 60, 
	"Free Sans", (1,1,1,1))
\end{lstlisting}
\section{REST API}
If the server is run using "restServer.py" instead of "server.py" it will take take http messages instead of standard API calls. These are formatted as "/api/<CALL NAME>". Ones which add or change information are "POST" requests while those which just request information are "GET" requests. Parameters should be passed into these REST calls as JSON structures. Returned information is returned as a JSON structure.\\
Logging in takes place automatically when using the REST server, so there is no need to call login() or setApp()
\section{Sending Images with REST API}
To display images to the rest API, a different method is used than the usual one that exists outside REST. Images are sent in the same calls that ask for them to be displayed. So, instead of a reference to the texture being included in the JSON for a call to /api/newTexRectangle, /api/newTexRectangleWithID, or /api/setTexRectangleTexture, the calls take the image data itself (converted to base64) and the file extension. These JSON parameters should be called "textureData" and "extension" respectively. I have created a python library called "jsonImageSender.py" which contains the class jsonImageSender which allows for easy sending of images. Here are the calls that this class provides.\\\\
\subsubsection{Constructor - jsonImageSender(host,port)}
Creates an instance of the class and tells it the host name and port number for the rest server for use in the provided call functions.
\subsubsection{newTexRectangle(windowNo, filename, x, y, width, height)}
Creates a base64 representation of the image with the chosen filename and sends it to the rest server to be displayed with the stated parameters.
\subsubsection{newTexRectangleWithID(ID,windowNo, filename, x, y, width, height)}
Creates a base64 representation of the image with the chosen filename and sends it to the rest server to be displayed with the stated parameters.
\subsubsection{setTexRectangleTexture(elementNo, filename)}
Creates a base64 representation of the image with the chosen filename and sends it to the rest server to replace the texture being used for the existing texRectangle with the stated element number.


\section{REST Hello World}
This example would be run in a UNIX terminal using "curl" assuming that the server is running on the same computer on port 5000.

\begin{lstlisting}[frame=single]
curl -i -H "Content-Type: application/json" 
	-X POST -d "{\surfaceNo\":0,\"x\":0,
	\"y\":512,\"width\":512,
	\"height\":512,\"coorSys\":\"pix\",
	\"name\":\"HWwin\"}"
	http://localhost:5000/api/newWindow

curl -i -H "Content-Type: application/json" 
	-X POST -d "{\"windowNo\":1,
	\"text\":\"Hello World\",\"x\":300,
	\"y\":300,\"coorSys\":\"pix\",
	\"ptSize\":60,\"font\":
	\"Free Sans\",\"color\":\"1:1:1:1\"
	}" http://localhost:5000/api/newText


\end{lstlisting}


\end{document}